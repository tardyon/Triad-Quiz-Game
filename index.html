<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Triad Quiz Game</title>
  <style>
    /* [Styles remain the same as before] */
  </style>
</head>
<body>

  <div class="container">
    <div class="main-content">
      <h1>Triad Quiz Game</h1>
      <p>This game helps you practice identifying the four types of triads. If a chord doesn't match the spelling of any of these types, consider choosing a different root note.</p>
      
      <div class="options">
        <h2>Select Triad Types:</h2>
        <label><input type="checkbox" id="major" checked> Major</label>
        <label><input type="checkbox" id="minor" checked> Minor</label>
        <label><input type="checkbox" id="diminished" checked> Diminished</label>
        <label><input type="checkbox" id="augmented" checked> Augmented</label>
      </div>
      
      <div class="options">
        <h2>Select Inversions:</h2>
        <label><input type="radio" name="inversion" value="root" checked> Only Root Position</label>
        <label><input type="radio" name="inversion" value="standard"> Standard Inversions</label>
        <label><input type="radio" name="inversion" value="spread"> Spread Voicings</label>
        <label><input type="radio" name="inversion" value="all"> All Voicings</label>
      </div>
      
      <div class="options">
        <h2>Select Quiz Mode:</h2>
        <label><input type="radio" name="mode" value="name" checked> Name the Chord</label>
        <label><input type="radio" name="mode" value="spell"> Spell the Chord</label>
      </div>
      
      <div style="text-align: center;">
        <button id="start-button">Start Quiz</button>
      </div>
      
      <div id="quiz-area" style="display: none;">
        <div id="quiz-question"></div>
        <button id="reveal-button">Reveal Answer (Space Bar)</button>
        <div id="answer" style="display: none;"></div>
        <button id="correct-button" style="display: none;">I Was Correct ('.' Key)</button>
        <button id="wrong-button" style="display: none;">I Was Wrong (',' Key)</button>
        <button id="reset-button">Reset Game</button>
        <div id="progress"></div>
      </div>
      
      <div id="footer">
        <p>Â© 2024 Michael C.M. Varney</p>
        <p>Version 1.5</p>
      </div>

      <!-- Moved Missed Questions to Bottom -->
      <div id="missed-questions">
        <h2>Missed Questions</h2>
        <ul id="missed-list"></ul>
      </div>

    </div>
  </div>
  
  <script>
    (function() {
      const circleOfFifths = [
        'C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#',
        'F', 'Bb', 'Eb', 'Ab', 'Db', 'Gb', 'Cb'
      ];

      const triadTypes = [
        { name: 'Major', formula: ['1', '3', '5'], symmetrical: false },
        { name: 'Minor', formula: ['1', 'b3', '5'], symmetrical: false },
        { name: 'Diminished', formula: ['1', 'b3', 'b5'], symmetrical: false },
        { name: 'Augmented', formula: ['1', '3', '#5'], symmetrical: true }
      ];

      const noteLetters = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];

      const semitoneMap = {
        'C': 0,
        'C#': 1,
        'Db': 1,
        'D': 2,
        'D#': 3,
        'Eb': 3,
        'E': 4,
        'F': 5,
        'F#': 6,
        'Gb': 6,
        'G': 7,
        'G#': 8,
        'Ab': 8,
        'A': 9,
        'A#': 10,
        'Bb': 10,
        'B': 11,
        'Cb': 11
      };

      const midiToNoteSharps = [
        'C', 'C#', 'D', 'D#', 'E', 'F',
        'F#', 'G', 'G#', 'A', 'A#', 'B'
      ];

      const midiToNoteFlats = [
        'C', 'Db', 'D', 'Eb', 'E', 'F',
        'Gb', 'G', 'Ab', 'A', 'Bb', 'B'
      ];

      let quizSet = [];
      let currentQuestionIndex = 0;
      let currentQuestion = null;
      let correctAnswers = 0;
      let incorrectAttempts = 0;
      let totalQuestions = 0;
      let missedQuestions = {};

      function buildMajorScale(root, useSharps) {
        const semitones = [0, 2, 4, 5, 7, 9, 11];
        const scale = [];
        const rootIndex = noteLetters.indexOf(root.charAt(0));
        for (let i = 0; i < 7; i++) {
          const letter = noteLetters[(rootIndex + i) % 7];
          const midi = (semitoneMap[root] + semitones[i]) % 12;
          const noteName = findNoteName(letter, midi, useSharps);
          if (!noteName) return null;
          scale.push(noteName);
        }
        return scale;
      }

      function findNoteName(letter, midi, useSharps) {
        const accidentals = useSharps ? ['bb', 'b', '', '#', '##'] : ['##', '#', '', 'b', 'bb'];
        for (let accidental of accidentals) {
          const noteName = letter + accidental;
          if (semitoneMap[noteName] !== undefined && semitoneMap[noteName] % 12 === midi) {
            return noteName;
          }
        }
        return null;
      }

      function generateTriad(root, formula) {
        const useSharps = !root.includes('b');
        const scale = buildMajorScale(root, useSharps);
        if (!scale) return null;

        const degreeMap = {
          '1': 0,
          '2': 1,
          '3': 2,
          '4': 3,
          '5': 4,
          '6': 5,
          '7': 6
        };

        const notes = formula.map(interval => {
          let degree = interval.replace(/b|#/g, '');
          let note = scale[degreeMap[degree]];
          if (interval.includes('b')) {
            note = flattenNote(note);
          } else if (interval.includes('#')) {
            note = sharpenNote(note);
          }
          return note;
        });

        // Verify that we haven't mixed sharps and flats
        const hasSharps = notes.some(n => n.includes('#'));
        const hasFlats = notes.some(n => n.includes('b'));
        if (hasSharps && hasFlats) return null;

        return notes;
      }

      function flattenNote(note) {
        if (note.endsWith('bb')) return note; // Avoid triple flats
        if (note.endsWith('b')) return note.replace('b', 'bb');
        if (note.endsWith('#')) return note.slice(0, -1);
        if (note.endsWith('##')) return note.replace('##', '#');
        return note + 'b';
      }

      function sharpenNote(note) {
        if (note.endsWith('##')) return note; // Avoid triple sharps
        if (note.endsWith('#')) return note.replace('#', '##');
        if (note.endsWith('b')) return note.slice(0, -1);
        if (note.endsWith('bb')) return note.replace('bb', 'b');
        return note + '#';
      }

      function generatePermutations(notes, inversionType, isSymmetrical) {
        const permutations = [];
        const inversions = [];

        if (isSymmetrical) {
          // For symmetrical chords (augmented triads), only include one permutation
          permutations.push(notes);
          inversions.push('No Inversions (Symmetrical Chord)');
        } else {
          // Generate permutations based on inversion type
          if (inversionType === 'root') {
            permutations.push(notes);
            inversions.push('Root Position');
          } else if (inversionType === 'standard') {
            // Root Position
            permutations.push(notes);
            inversions.push('Root Position');
            // First Inversion
            permutations.push([notes[1], notes[2], notes[0]]);
            inversions.push('First Inversion');
            // Second Inversion
            permutations.push([notes[2], notes[0], notes[1]]);
            inversions.push('Second Inversion');
          } else if (inversionType === 'spread') {
            // Generate spread voicings
            const allPermutations = permute(notes);
            allPermutations.forEach(perm => {
              if (!isStandardInversion(perm, notes)) {
                permutations.push(perm);
                inversions.push('Spread Voicing');
              }
            });
          } else if (inversionType === 'all') {
            // All voicings
            const allPermutations = permute(notes);
            allPermutations.forEach(perm => {
              const inversion = getInversionName(perm, notes);
              permutations.push(perm);
              inversions.push(inversion);
            });
          }
        }

        // Remove duplicate permutations
        const uniquePermutations = [];
        const uniqueInversions = [];
        const seen = new Set();
        for (let i = 0; i < permutations.length; i++) {
          const key = permutations[i].join('-');
          if (!seen.has(key)) {
            seen.add(key);
            uniquePermutations.push(permutations[i]);
            uniqueInversions.push(inversions[i]);
          }
        }

        return uniquePermutations.map((perm, idx) => ({
          notes: perm,
          inversion: uniqueInversions[idx]
        }));
      }

      function permute(arr) {
        const result = [];

        function generate(n, heapArr) {
          if (n === 1) {
            result.push(heapArr.slice());
          } else {
            for (let i = 0; i < n; i++) {
              generate(n - 1, heapArr);
              const j = n % 2 === 0 ? i : 0;
              [heapArr[n - 1], heapArr[j]] = [heapArr[j], heapArr[n - 1]];
            }
          }
        }

        generate(arr.length, arr.slice());
        return result;
      }

      function isStandardInversion(perm, original) {
        return (
          (perm[0] === original[0] && perm[1] === original[1] && perm[2] === original[2]) ||
          (perm[0] === original[1] && perm[1] === original[2] && perm[2] === original[0]) ||
          (perm[0] === original[2] && perm[1] === original[0] && perm[2] === original[1])
        );
      }

      function getInversionName(perm, original) {
        if (perm[0] === original[0] && perm[1] === original[1] && perm[2] === original[2]) {
          return 'Root Position';
        } else if (perm[0] === original[1] && perm[1] === original[2] && perm[2] === original[0]) {
          return 'First Inversion';
        } else if (perm[0] === original[2] && perm[1] === original[0] && perm[2] === original[1]) {
          return 'Second Inversion';
        } else {
          return 'Spread Voicing';
        }
      }

      function initializeQuiz() {
        // Get user selections
        const selectedTypes = [];
        if (document.getElementById('major').checked) selectedTypes.push('Major');
        if (document.getElementById('minor').checked) selectedTypes.push('Minor');
        if (document.getElementById('diminished').checked) selectedTypes.push('Diminished');
        if (document.getElementById('augmented').checked) selectedTypes.push('Augmented');

        const inversionRadios = document.getElementsByName('inversion');
        let inversionType = 'root';
        for (let radio of inversionRadios) {
          if (radio.checked) {
            inversionType = radio.value;
            break;
          }
        }

        const modeRadios = document.getElementsByName('mode');
        let quizMode = 'name';
        for (let radio of modeRadios) {
          if (radio.checked) {
            quizMode = radio.value;
            break;
          }
        }

        // Generate quiz set
        quizSet = [];
        missedQuestions = {};
        circleOfFifths.forEach(root => {
          triadTypes.forEach(triadType => {
            if (selectedTypes.includes(triadType.name)) {
              const triadNotes = generateTriad(root, triadType.formula);
              if (!triadNotes) return;
              const permutations = generatePermutations(triadNotes, inversionType, triadType.symmetrical);
              permutations.forEach(perm => {
                const questionKey = quizMode === 'name' ? perm.notes.join('â¯ââ¯') : `${root} ${triadType.name} Triad (${perm.inversion})`;
                quizSet.push({
                  question: perm.notes.join('â¯ââ¯'),
                  answer: `${root} ${triadType.name} Triad`,
                  inversion: perm.inversion,
                  quizMode: quizMode,
                  key: questionKey,
                  isSymmetrical: triadType.symmetrical,
                  notes: perm.notes // Store notes for augmented triads
                });
              });
            }
          });
        });

        // Shuffle quiz set
        quizSet = shuffleArray(quizSet);

        // Initialize counters
        currentQuestionIndex = 0;
        correctAnswers = 0;
        incorrectAttempts = 0;
        totalQuestions = quizSet.length;

        // Hide start button and show quiz area
        document.getElementById('start-button').style.display = 'none';
        document.getElementById('quiz-area').style.display = 'block';
        document.getElementById('missed-list').innerHTML = '';

        showNextQuestion();
      }

      function showNextQuestion() {
        if (quizSet.length === 0) {
          // Quiz completed
          document.getElementById('quiz-question').textContent = 'Quiz Completed!';
          document.getElementById('reveal-button').style.display = 'none';
          document.getElementById('correct-button').style.display = 'none';
          document.getElementById('wrong-button').style.display = 'none';
          document.getElementById('answer').style.display = 'none';
          document.getElementById('progress').textContent = `Final Score: ${correctAnswers} Correct, ${incorrectAttempts} Incorrect Attempts`;
          return;
        }

        currentQuestion = quizSet[currentQuestionIndex];
        if (currentQuestion.quizMode === 'name') {
          document.getElementById('quiz-question').textContent = `What is the chord for: ${currentQuestion.question}?`;
        } else {
          document.getElementById('quiz-question').textContent = `Spell the ${currentQuestion.answer}${currentQuestion.isSymmetrical ? '' : ' (' + currentQuestion.inversion + ')'}`;
        }
        document.getElementById('answer').style.display = 'none';
        document.getElementById('correct-button').style.display = 'none';
        document.getElementById('wrong-button').style.display = 'none';
        document.getElementById('reveal-button').style.display = 'inline-block';
        document.getElementById('progress').textContent = `Correct: ${correctAnswers}, Incorrect Attempts: ${incorrectAttempts}, Remaining Questions: ${quizSet.length}`;
      }

      function revealAnswer() {
        let inversionInfo = '';
        if (currentQuestion.isSymmetrical) {
          inversionInfo = 'Note: Augmented triads are symmetrical and have no inversions.';
        } else {
          inversionInfo = `(${currentQuestion.inversion})`;
        }

        if (currentQuestion.quizMode === 'name') {
          if (currentQuestion.isSymmetrical) {
            // For augmented triads, list all possible root notes
            const rootNotes = currentQuestion.notes.join(', ');
            document.getElementById('answer').textContent = `Answer: ${rootNotes} Augmented Triad. ${inversionInfo}`;
          } else {
            document.getElementById('answer').textContent = `Answer: ${currentQuestion.answer} ${inversionInfo}`;
          }
        } else {
          document.getElementById('answer').textContent = `Answer: ${currentQuestion.question} ${inversionInfo}`;
        }
        document.getElementById('answer').style.display = 'block';
        document.getElementById('correct-button').style.display = 'inline-block';
        document.getElementById('wrong-button').style.display = 'inline-block';
        document.getElementById('reveal-button').style.display = 'none';
      }

      function handleCorrect() {
        correctAnswers++;
        quizSet.splice(currentQuestionIndex, 1);
        if (currentQuestionIndex >= quizSet.length) {
          currentQuestionIndex = 0;
        }
        showNextQuestion();
      }

      function handleWrong() {
        incorrectAttempts++;
        // Track missed questions
        const key = currentQuestion.key;
        if (missedQuestions[key]) {
          missedQuestions[key]++;
        } else {
          missedQuestions[key] = 1;
        }
        updateMissedQuestions();
        currentQuestionIndex++;
        if (currentQuestionIndex >= quizSet.length) {
          currentQuestionIndex = 0;
        }
        showNextQuestion();
      }

      function updateMissedQuestions() {
        const missedList = document.getElementById('missed-list');
        missedList.innerHTML = '';
        for (const [question, count] of Object.entries(missedQuestions)) {
          const li = document.createElement('li');
          li.textContent = `${question} - Missed ${count} time(s)`;
          missedList.appendChild(li);
        }
      }

      function resetGame() {
        // Reset the quiz area
        document.getElementById('quiz-area').style.display = 'none';
        document.getElementById('start-button').style.display = 'inline-block';
        document.getElementById('reveal-button').style.display = 'inline-block';
        document.getElementById('correct-button').style.display = 'none';
        document.getElementById('wrong-button').style.display = 'none';
        document.getElementById('answer').style.display = 'none';
        document.getElementById('quiz-question').textContent = '';
        document.getElementById('progress').textContent = '';
        document.getElementById('missed-list').innerHTML = '';
        missedQuestions = {};
      }

      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }

      // Event listeners
      document.getElementById('start-button').addEventListener('click', initializeQuiz);
      document.getElementById('reveal-button').addEventListener('click', revealAnswer);
      document.getElementById('correct-button').addEventListener('click', handleCorrect);
      document.getElementById('wrong-button').addEventListener('click', handleWrong);
      document.getElementById('reset-button').addEventListener('click', resetGame);

      // Keyboard event listeners
      document.addEventListener('keydown', function(event) {
        if (event.key === ' ') {
          event.preventDefault(); // Prevent scrolling
          if (document.getElementById('reveal-button').style.display !== 'none') {
            revealAnswer();
          }
        } else if (event.key === '.') {
          if (document.getElementById('correct-button').style.display !== 'none') {
            handleCorrect();
          }
        } else if (event.key === ',') {
          if (document.getElementById('wrong-button').style.display !== 'none') {
            handleWrong();
          }
        }
      });

    })();
  </script>
  
</body>
</html>
